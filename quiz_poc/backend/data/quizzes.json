{
  "quizzes": [
    {
      "id": 1,
      "title": "'文字列からパスパラメータ名の集合を取得する'",
      "description": "'\\n対象コードの `get_path_param_names` 関数にある\\n\\n    return set(re.findall(\"{(.*?)}\", path))\\n\\nの処理を参考にします。\\n\\n変数 `sysin` にはパス文字列が代入されます。\\nこのパス文字列の中から、`{...}` で囲まれている部分をすべて正規表現で抽出し、\\nそれらを要素とする `set` を作成して、標準出力してください。\\n\\nヒント:\\n- `import re` を行ってください\\n- `re.findall` を使って `{}` の中身をすべて取り出してください\\n- 結果は `set` 型のまま `print` して構いません\\n'",
      "sysin_format": "'\"/items/{item_id}/users/{user_id}\" のようなパス文字列'",
      "sample_code": "'\\nimport re\\n\\npath = sysin\\nnames = set(re.findall(r\"{(.*?)}\", path))\\nprint(names)\\n'",
      "testcases": [
        {
          "sysin": "'/items/{item_id}/users/{user_id}'",
          "expected": "{'user_id', 'item_id'}"
        },
        {
          "sysin": "'/no/params/here'",
          "expected": "set()"
        },
        {
          "sysin": "'/{one}/{two}/{one}'",
          "expected": "{'two', 'one'}"
        }
      ]
    },
    {
      "id": 2,
      "title": "'HTTPステータスコードでレスポンスボディが許可されるか判定する'",
      "description": "'\\n対象コードの `is_body_allowed_for_status_code` 関数の先頭付近にある\\n\\n    if status_code is None:\\n        return True\\n\\nおよび\\n\\n    if status_code in {\\n        \"default\",\\n        \"1XX\",\\n        \"2XX\",\\n        \"3XX\",\\n        \"4XX\",\\n        \"5XX\",\\n    }:\\n        return True\\n\\nさらに\\n\\n    current_status_code = int(status_code)\\n    return not (current_status_code < 200 or current_status_code in {204, 205, 304})\\n\\nという処理を参考にします。\\n\\n変数 `sysin` には、`int`, `str`, もしくは `None` が代入されます。\\nこの値を HTTP ステータスコードとして解釈し、\\nレスポンスボディが「許可される場合」は `True`、「許可されない場合」は `False` を標準出力してください。\\n\\n条件:\\n- `sysin` が `None` のときは `True`\\n- `sysin` が `\"default\"`, `\"1XX\"`, `\"2XX\"`, `\"3XX\"`, `\"4XX\"`, `\"5XX\"` のいずれかの文字列のときは `True`\\n- それ以外は `int(sysin)` で整数に変換し、\\n  - 200 未満、または `204`, `205`, `304` のときは `False`\\n  - それ以外は `True`\\n'",
      "sysin_format": "'None または HTTPステータスコード (int もしくは str)'",
      "sample_code": "'\\nstatus_code = sysin\\n\\nif status_code is None:\\n    print(True)\\nelif status_code in {\"default\", \"1XX\", \"2XX\", \"3XX\", \"4XX\", \"5XX\"}:\\n    print(True)\\nelse:\\n    current_status_code = int(status_code)\\n    result = not (current_status_code < 200 or current_status_code in {204, 205, 304})\\n    print(result)\\n'",
      "testcases": [
        {
          "sysin": "200",
          "expected": "True"
        },
        {
          "sysin": "204",
          "expected": "False"
        },
        {
          "sysin": "'1XX'",
          "expected": "True"
        }
      ]
    },
    {
      "id": 3,
      "title": "'正規表現で操作IDを生成する'",
      "description": "'\\n対象コードの `generate_operation_id_for_path` 関数内にある\\n\\n    operation_id = f\"{name}{path}\"\\n    operation_id = re.sub(r\"\\\\W\", \"_\", operation_id)\\n    operation_id = f\"{operation_id}_{method.lower()}\"\\n\\nという処理を参考にします。\\n\\n変数 `sysin` には、`(name, path, method)` の3要素からなるタプルが代入されます。\\nこの3つの値を用いて、次の手順で文字列 `operation_id` を生成し、標準出力してください。\\n\\n1. `name` と `path` を連結して 1 つの文字列にする\\n2. その文字列中の「英数字とアンダースコア以外」の文字を、正規表現 `re.sub(r\"\\\\W\", \"_\", ...)` を使って `_` に置き換える\\n3. 末尾に `_` と `method` を小文字にした文字列を連結する\\n\\nヒント:\\n- `import re` を行ってください\\n- タプルの要素は `name, path, method = sysin` のように取り出せます\\n'",
      "sysin_format": "'(\"関数名\", \"/path/{param}\", \"HTTPメソッド\") の3要素タプル'",
      "sample_code": "'\\nimport re\\n\\nname, path, method = sysin\\noperation_id = f\"{name}{path}\"\\noperation_id = re.sub(r\"\\\\W\", \"_\", operation_id)\\noperation_id = f\"{operation_id}_{method.lower()}\"\\nprint(operation_id)\\n'",
      "testcases": [
        {
          "sysin": "('read_item', '/items/{item_id}', 'GET')",
          "expected": "'read_item_items__item_id__get'"
        },
        {
          "sysin": "('create-user', '/users/', 'POST')",
          "expected": "'create_user_users__post'"
        },
        {
          "sysin": "('op', '/a/b?x=1', 'DELETE')",
          "expected": "'op_a_b_x_1_delete'"
        }
      ]
    },
    {
      "id": 4,
      "title": "'二つの辞書を再帰的にマージする（deep_dict_update の条件分岐）'",
      "description": "'\\n対象コードの `deep_dict_update` 関数にある次の部分を参考にします。\\n\\n    for key, value in update_dict.items():\\n        if (\\n            key in main_dict\\n            and isinstance(main_dict[key], dict)\\n            and isinstance(value, dict)\\n        ):\\n            deep_dict_update(main_dict[key], value)\\n        elif (\\n            key in main_dict\\n            and isinstance(main_dict[key], list)\\n            and isinstance(update_dict[key], list)\\n        ):\\n            main_dict[key] = main_dict[key] + update_dict[key]\\n        else:\\n            main_dict[key] = value\\n\\n変数 `sysin` には `(main_dict, update_dict)` の2要素タプルが代入されます。\\nこの2つの辞書を上記ロジックどおりにマージした結果の `main_dict` を標準出力してください。\\n\\n仕様:\\n- 同じキーに対して両方とも値が辞書であれば、再帰的にマージする\\n- 同じキーに対して両方とも値がリストであれば、`main_dict[key] + update_dict[key]` で連結する\\n- それ以外の場合は、`update_dict` 側の値で上書きする\\n\\nヒント:\\n- 実装は関数にしてもしなくても構いません\\n- もとの `main_dict` を直接更新して構いません\\n'",
      "sysin_format": "'({ ... } , { ... }) の2つの辞書からなるタプル'",
      "sample_code": "'\\ndef deep_dict_update(main_dict, update_dict):\\n    for key, value in update_dict.items():\\n        if (\\n            key in main_dict\\n            and isinstance(main_dict[key], dict)\\n            and isinstance(value, dict)\\n        ):\\n            deep_dict_update(main_dict[key], value)\\n        elif (\\n            key in main_dict\\n            and isinstance(main_dict[key], list)\\n            and isinstance(update_dict[key], list)\\n        ):\\n            main_dict[key] = main_dict[key] + update_dict[key]\\n        else:\\n            main_dict[key] = value\\n\\nmain_dict, update_dict = sysin\\ndeep_dict_update(main_dict, update_dict)\\nprint(main_dict)\\n'",
      "testcases": [
        {
          "sysin": "({'a': 1, 'b': {'x': 1}}, {'b': {'y': 2}, 'c': 3})",
          "expected": "{'a': 1, 'b': {'x': 1, 'y': 2}, 'c': 3}"
        },
        {
          "sysin": "({'lst': [1, 2], 'v': 10}, {'lst': [3], 'v': 20})",
          "expected": "{'lst': [1, 2, 3], 'v': 20}"
        },
        {
          "sysin": "({'d': {'k': [1]}}, {'d': {'k': [2]}, 'e': {}})",
          "expected": "{'d': {'k': [1, 2]}, 'e': {}}"
        }
      ]
    },
    {
      "id": 5,
      "title": "'優先順位付きでデフォルト値を選ぶ'",
      "description": "'\\n対象コードの `get_value_or_default` 関数にある\\n\\n    items = (first_item,) + extra_items\\n    for item in items:\\n        if not isinstance(item, DefaultPlaceholder):\\n            return item\\n    return first_item\\n\\nのロジックを、より単純な型で再現します。\\n\\nここでは `DefaultPlaceholder` の代わりに、文字列 `\"DEFAULT\"` を使います。\\n変数 `sysin` には、1個以上の要素を持つタプルが代入され、\\n各要素は任意の値か文字列 `\"DEFAULT\"` です。\\n\\n仕様:\\n- 左から順に要素を見ていき、最初に `\"DEFAULT\"` ではない要素があれば、それを選ぶ\\n- すべて `\"DEFAULT\"` の場合は、最初の要素（=`\"DEFAULT\"`）を選ぶ\\n- 選ばれた値を標準出力してください\\n\\nヒント:\\n- タプルをそのまま `for` でループできます\\n- `all(...)` を使う必要はありません\\n'",
      "sysin_format": "'(\"DEFAULT\", \"DEFAULT\", 3) のような複数要素タプル'",
      "sample_code": "'\\nitems = sysin\\n\\nchosen = None\\nfor item in items:\\n    if item != \"DEFAULT\":\\n        chosen = item\\n        break\\n\\nif chosen is None:\\n    chosen = items[0]\\n\\nprint(chosen)\\n'",
      "testcases": [
        {
          "sysin": "('DEFAULT', 'DEFAULT', 3)",
          "expected": "3"
        },
        {
          "sysin": "('DEFAULT', 'x', 'y')",
          "expected": "'x'"
        },
        {
          "sysin": "('DEFAULT', 'DEFAULT')",
          "expected": "'DEFAULT'"
        }
      ]
    }
  ]
}